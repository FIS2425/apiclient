/* tslint:disable */
/* eslint-disable */
/**
 * API Gateway Documentation
 * Automatically merged API documentation
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ApiV1AppointmentsAvailableGet200ResponseInner
 */
export interface ApiV1AppointmentsAvailableGet200ResponseInner {
    /**
     * Start time of the available appointment slot
     * @type {string}
     * @memberof ApiV1AppointmentsAvailableGet200ResponseInner
     */
    'startTime'?: string;
    /**
     * End time of the available appointment slot
     * @type {string}
     * @memberof ApiV1AppointmentsAvailableGet200ResponseInner
     */
    'endTime'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1AppointmentsAvailableGet500Response
 */
export interface ApiV1AppointmentsAvailableGet500Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1AppointmentsAvailableGet500Response
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1AppointmentsAvailableGet500Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1AppointmentsIdDelete200Response
 */
export interface ApiV1AppointmentsIdDelete200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1AppointmentsIdDelete200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1LoginPost401Response
 */
export interface ApiV1LoginPost401Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1LoginPost401Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1LoginPostRequest
 */
export interface ApiV1LoginPostRequest {
    /**
     * The user\'s unique email.
     * @type {string}
     * @memberof ApiV1LoginPostRequest
     */
    'email': string;
    /**
     * The user\'s password.
     * @type {string}
     * @memberof ApiV1LoginPostRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ApiV1LogoutPost200Response
 */
export interface ApiV1LogoutPost200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1LogoutPost200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1LogoutPost401Response
 */
export interface ApiV1LogoutPost401Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1LogoutPost401Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1UsersChangePasswordPost200Response
 */
export interface ApiV1UsersChangePasswordPost200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersChangePasswordPost200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1UsersChangePasswordPost400Response
 */
export interface ApiV1UsersChangePasswordPost400Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersChangePasswordPost400Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1UsersChangePasswordPost401Response
 */
export interface ApiV1UsersChangePasswordPost401Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersChangePasswordPost401Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1UsersChangePasswordPost500Response
 */
export interface ApiV1UsersChangePasswordPost500Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersChangePasswordPost500Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1UsersChangePasswordPostRequest
 */
export interface ApiV1UsersChangePasswordPostRequest {
    /**
     * The current password of the user.
     * @type {string}
     * @memberof ApiV1UsersChangePasswordPostRequest
     */
    'currentPassword': string;
    /**
     * The new password to set.
     * @type {string}
     * @memberof ApiV1UsersChangePasswordPostRequest
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface ApiV1UsersEnable2faPost200Response
 */
export interface ApiV1UsersEnable2faPost200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersEnable2faPost200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersEnable2faPost200Response
     */
    'qrCodeUrl'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1UsersEnable2faPost400Response
 */
export interface ApiV1UsersEnable2faPost400Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersEnable2faPost400Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1UsersEnable2faPost500Response
 */
export interface ApiV1UsersEnable2faPost500Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersEnable2faPost500Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1UsersIdDelete204Response
 */
export interface ApiV1UsersIdDelete204Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersIdDelete204Response
     */
    '_id'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1UsersIdGet200Response
 */
export interface ApiV1UsersIdGet200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersIdGet200Response
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersIdGet200Response
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersIdGet200Response
     */
    'username'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiV1UsersIdGet200Response
     */
    'roles'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersIdGet200Response
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersIdGet200Response
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1UsersIdGet401Response
 */
export interface ApiV1UsersIdGet401Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersIdGet401Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1UsersIdPut200Response
 */
export interface ApiV1UsersIdPut200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersIdPut200Response
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersIdPut200Response
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiV1UsersIdPut200Response
     */
    'roles'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersIdPut200Response
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersIdPut200Response
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1UsersIdPutRequest
 */
export interface ApiV1UsersIdPutRequest {
    /**
     * Email address of the user.
     * @type {string}
     * @memberof ApiV1UsersIdPutRequest
     */
    'email'?: string;
    /**
     * User\'s password.
     * @type {string}
     * @memberof ApiV1UsersIdPutRequest
     */
    'password'?: string;
    /**
     * List of roles assigned to the user.
     * @type {Array<string>}
     * @memberof ApiV1UsersIdPutRequest
     */
    'roles'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ApiV1UsersPost201Response
 */
export interface ApiV1UsersPost201Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersPost201Response
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApiV1UsersPost201Response
     */
    'roles'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersPost201Response
     */
    'doctorid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersPost201Response
     */
    'patientid'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiV1UsersPost401Response
 */
export interface ApiV1UsersPost401Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersPost401Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1UsersPost403Response
 */
export interface ApiV1UsersPost403Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersPost403Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1UsersPostRequest
 */
export interface ApiV1UsersPostRequest {
    /**
     * Email address of the user.
     * @type {string}
     * @memberof ApiV1UsersPostRequest
     */
    'email': string;
    /**
     * User\'s password.
     * @type {string}
     * @memberof ApiV1UsersPostRequest
     */
    'password': string;
    /**
     * List of roles assigned to the user.
     * @type {Array<string>}
     * @memberof ApiV1UsersPostRequest
     */
    'roles'?: Array<string>;
    /**
     * Unique ID if the user is a doctor.
     * @type {string}
     * @memberof ApiV1UsersPostRequest
     */
    'doctorid'?: string | null;
    /**
     * Unique ID if the user is a patient.
     * @type {string}
     * @memberof ApiV1UsersPostRequest
     */
    'patientid'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiV1UsersVerify2faPost200Response
 */
export interface ApiV1UsersVerify2faPost200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersVerify2faPost200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1UsersVerify2faPost400Response
 */
export interface ApiV1UsersVerify2faPost400Response {
    /**
     * 
     * @type {string}
     * @memberof ApiV1UsersVerify2faPost400Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1UsersVerify2faPostRequest
 */
export interface ApiV1UsersVerify2faPostRequest {
    /**
     * The user\'s unique ID.
     * @type {string}
     * @memberof ApiV1UsersVerify2faPostRequest
     */
    'userId': string;
    /**
     * The two-factor authentication token.
     * @type {string}
     * @memberof ApiV1UsersVerify2faPostRequest
     */
    'totpToken': string;
}
/**
 * 
 * @export
 * @interface ApiV1WorkshiftsWeekPost400Response
 */
export interface ApiV1WorkshiftsWeekPost400Response {
    /**
     * Error message explaining the issue
     * @type {string}
     * @memberof ApiV1WorkshiftsWeekPost400Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ApiV1WorkshiftsWeekPostRequest
 */
export interface ApiV1WorkshiftsWeekPostRequest {
    /**
     * Unique identifier for the doctor
     * @type {string}
     * @memberof ApiV1WorkshiftsWeekPostRequest
     */
    'doctorId': string;
    /**
     * Unique identifier for the clinic
     * @type {string}
     * @memberof ApiV1WorkshiftsWeekPostRequest
     */
    'clinicId': string;
    /**
     * Duration of each work shift in minutes
     * @type {number}
     * @memberof ApiV1WorkshiftsWeekPostRequest
     */
    'duration': number;
    /**
     * Start date of the week, must be a Monday
     * @type {string}
     * @memberof ApiV1WorkshiftsWeekPostRequest
     */
    'periodStartDate'?: string;
    /**
     * End date of the week, must be a Sunday within the same week as weekStartDate
     * @type {string}
     * @memberof ApiV1WorkshiftsWeekPostRequest
     */
    'periodEndDate'?: string;
}
/**
 * 
 * @export
 * @interface Appointment
 */
export interface Appointment {
    /**
     * Unique identifier for the appointment
     * @type {string}
     * @memberof Appointment
     */
    'id'?: string;
    /**
     * ID of the patient associated with the appointment
     * @type {string}
     * @memberof Appointment
     */
    'patientId'?: string;
    /**
     * ID of the clinic where the appointment is scheduled
     * @type {string}
     * @memberof Appointment
     */
    'clinicId'?: string;
    /**
     * ID of the doctor handling the appointment
     * @type {string}
     * @memberof Appointment
     */
    'doctorId'?: string;
    /**
     * Medical specialty for the appointment
     * @type {string}
     * @memberof Appointment
     */
    'specialty'?: AppointmentSpecialtyEnum;
    /**
     * Date and time of the appointment
     * @type {string}
     * @memberof Appointment
     */
    'appointmentDate'?: string;
    /**
     * Current status of the appointment
     * @type {string}
     * @memberof Appointment
     */
    'status'?: AppointmentStatusEnum;
    /**
     * Appointment creation timestamp
     * @type {string}
     * @memberof Appointment
     */
    'createdAt'?: string;
}

export const AppointmentSpecialtyEnum = {
    FamilyMedicine: 'family_medicine',
    Nursing: 'nursing',
    Physiotherapy: 'physiotherapy',
    Gynecology: 'gynecology',
    Pediatrics: 'pediatrics',
    Dermatology: 'dermatology',
    Cardiology: 'cardiology',
    Neurology: 'neurology',
    Orthopedics: 'orthopedics',
    Psychiatry: 'psychiatry',
    Endocrinology: 'endocrinology',
    Oncology: 'oncology',
    Radiology: 'radiology',
    Surgery: 'surgery',
    Ophthalmology: 'ophthalmology',
    Urology: 'urology',
    Anesthesiology: 'anesthesiology',
    Otolaryngology: 'otolaryngology',
    Gastroenterology: 'gastroenterology',
    Other: 'other'
} as const;

export type AppointmentSpecialtyEnum = typeof AppointmentSpecialtyEnum[keyof typeof AppointmentSpecialtyEnum];
export const AppointmentStatusEnum = {
    Pending: 'pending',
    Completed: 'completed',
    Cancelled: 'cancelled',
    NoShow: 'no-show'
} as const;

export type AppointmentStatusEnum = typeof AppointmentStatusEnum[keyof typeof AppointmentStatusEnum];

/**
 * 
 * @export
 * @interface AppointmentCreate
 */
export interface AppointmentCreate {
    /**
     * ID of the patient for whom the appointment is created
     * @type {string}
     * @memberof AppointmentCreate
     */
    'patientId': string;
    /**
     * ID of the clinic where the appointment will be held
     * @type {string}
     * @memberof AppointmentCreate
     */
    'clinicId': string;
    /**
     * ID of the doctor for the appointment
     * @type {string}
     * @memberof AppointmentCreate
     */
    'doctorId': string;
    /**
     * Medical specialty for the appointment
     * @type {string}
     * @memberof AppointmentCreate
     */
    'specialty': AppointmentCreateSpecialtyEnum;
    /**
     * Date and time of the appointment
     * @type {string}
     * @memberof AppointmentCreate
     */
    'appointmentDate': string;
}

export const AppointmentCreateSpecialtyEnum = {
    FamilyMedicine: 'family_medicine',
    Nursing: 'nursing',
    Physiotherapy: 'physiotherapy',
    Gynecology: 'gynecology',
    Pediatrics: 'pediatrics',
    Dermatology: 'dermatology',
    Cardiology: 'cardiology',
    Neurology: 'neurology',
    Orthopedics: 'orthopedics',
    Psychiatry: 'psychiatry',
    Endocrinology: 'endocrinology',
    Oncology: 'oncology',
    Radiology: 'radiology',
    Surgery: 'surgery',
    Ophthalmology: 'ophthalmology',
    Urology: 'urology',
    Anesthesiology: 'anesthesiology',
    Otolaryngology: 'otolaryngology',
    Gastroenterology: 'gastroenterology',
    Other: 'other'
} as const;

export type AppointmentCreateSpecialtyEnum = typeof AppointmentCreateSpecialtyEnum[keyof typeof AppointmentCreateSpecialtyEnum];

/**
 * 
 * @export
 * @interface AppointmentUpdate
 */
export interface AppointmentUpdate {
    /**
     * Updated medical specialty for the appointment
     * @type {string}
     * @memberof AppointmentUpdate
     */
    'specialty'?: AppointmentUpdateSpecialtyEnum;
    /**
     * Updated date and time of the appointment
     * @type {string}
     * @memberof AppointmentUpdate
     */
    'appointmentDate'?: string;
    /**
     * Updated status of the appointment
     * @type {string}
     * @memberof AppointmentUpdate
     */
    'status'?: AppointmentUpdateStatusEnum;
}

export const AppointmentUpdateSpecialtyEnum = {
    FamilyMedicine: 'family_medicine',
    Nursing: 'nursing',
    Physiotherapy: 'physiotherapy',
    Gynecology: 'gynecology',
    Pediatrics: 'pediatrics',
    Dermatology: 'dermatology',
    Cardiology: 'cardiology',
    Neurology: 'neurology',
    Orthopedics: 'orthopedics',
    Psychiatry: 'psychiatry',
    Endocrinology: 'endocrinology',
    Oncology: 'oncology',
    Radiology: 'radiology',
    Surgery: 'surgery',
    Ophthalmology: 'ophthalmology',
    Urology: 'urology',
    Anesthesiology: 'anesthesiology',
    Otolaryngology: 'otolaryngology',
    Gastroenterology: 'gastroenterology',
    Other: 'other'
} as const;

export type AppointmentUpdateSpecialtyEnum = typeof AppointmentUpdateSpecialtyEnum[keyof typeof AppointmentUpdateSpecialtyEnum];
export const AppointmentUpdateStatusEnum = {
    Pending: 'pending',
    Completed: 'completed',
    Cancelled: 'cancelled',
    NoShow: 'no-show'
} as const;

export type AppointmentUpdateStatusEnum = typeof AppointmentUpdateStatusEnum[keyof typeof AppointmentUpdateStatusEnum];

/**
 * Schema for the User model, including fields for unique ID, email, password, role, and optional associations with patient and clinic.
 * @export
 * @interface User
 */
export interface User {
    /**
     * Unique identifier for the user. Defaults to a generated UUID.
     * @type {string}
     * @memberof User
     */
    '_id'?: string;
    /**
     * Unique email for the user.
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * Hashed password of the user.
     * @type {string}
     * @memberof User
     */
    'password': string;
    /**
     * List of roles assigned to the user.
     * @type {Array<string>}
     * @memberof User
     */
    'roles': Array<UserRolesEnum>;
    /**
     * Identifier of the doctor if the user is a clinic doctor.
     * @type {string}
     * @memberof User
     */
    'doctorid'?: string | null;
    /**
     * Identifier of the patient if the user is associated with a patient record.
     * @type {string}
     * @memberof User
     */
    'patientid'?: string | null;
    /**
     * Timestamp when the user was created.
     * @type {string}
     * @memberof User
     */
    'createdAt'?: string;
    /**
     * Timestamp when the user was last updated.
     * @type {string}
     * @memberof User
     */
    'updatedAt'?: string;
}

export const UserRolesEnum = {
    Admin: 'admin',
    Clinicadmin: 'clinicadmin',
    Doctor: 'doctor',
    Patient: 'patient'
} as const;

export type UserRolesEnum = typeof UserRolesEnum[keyof typeof UserRolesEnum];

/**
 * 
 * @export
 * @interface ValidateToken200Response
 */
export interface ValidateToken200Response {
    /**
     * 
     * @type {string}
     * @memberof ValidateToken200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ValidateToken401Response
 */
export interface ValidateToken401Response {
    /**
     * 
     * @type {string}
     * @memberof ValidateToken401Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Workshift
 */
export interface Workshift {
    /**
     * 
     * @type {string}
     * @memberof Workshift
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Workshift
     */
    'doctorId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Workshift
     */
    'clinicId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Workshift
     */
    'startDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof Workshift
     */
    'duration'?: number;
}
/**
 * 
 * @export
 * @interface WorkshiftInput
 */
export interface WorkshiftInput {
    /**
     * 
     * @type {string}
     * @memberof WorkshiftInput
     */
    'doctorId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkshiftInput
     */
    'clinicId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkshiftInput
     */
    'startDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkshiftInput
     */
    'duration'?: number;
}

/**
 * AppointmentsApi - axios parameter creator
 * @export
 */
export const AppointmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve available appointment slots for a specific clinic, doctor, and date.
         * @summary Get available appointment slots
         * @param {string} clinicId The ID of the clinic to check for available appointments
         * @param {string} doctorId The ID of the doctor to check for available appointments
         * @param {string} date The date to check for available appointments (in YYYY-MM-DD format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsAvailableGet: async (clinicId: string, doctorId: string, date: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clinicId' is not null or undefined
            assertParamExists('apiV1AppointmentsAvailableGet', 'clinicId', clinicId)
            // verify required parameter 'doctorId' is not null or undefined
            assertParamExists('apiV1AppointmentsAvailableGet', 'doctorId', doctorId)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('apiV1AppointmentsAvailableGet', 'date', date)
            const localVarPath = `/api/v1/appointments/available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required

            if (clinicId !== undefined) {
                localVarQueryParameter['clinicId'] = clinicId;
            }

            if (doctorId !== undefined) {
                localVarQueryParameter['doctorId'] = doctorId;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substring(0,10) :
                    date;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all appointments for a specific clinic by its ID.
         * @summary Get all appointments for a clinic
         * @param {string} clinicId The ID of the clinic whose appointments to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsClinicClinicIdGet: async (clinicId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clinicId' is not null or undefined
            assertParamExists('apiV1AppointmentsClinicClinicIdGet', 'clinicId', clinicId)
            const localVarPath = `/api/v1/appointments/clinic/{clinicId}`
                .replace(`{${"clinicId"}}`, encodeURIComponent(String(clinicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all appointments for a specific doctor by their ID.
         * @summary Get all appointments for a doctor
         * @param {string} doctorId The ID of the doctor whose appointments to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsDoctorDoctorIdGet: async (doctorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'doctorId' is not null or undefined
            assertParamExists('apiV1AppointmentsDoctorDoctorIdGet', 'doctorId', doctorId)
            const localVarPath = `/api/v1/appointments/doctor/{doctorId}`
                .replace(`{${"doctorId"}}`, encodeURIComponent(String(doctorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all appointments in the system.
         * @summary Get all appointments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/appointments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change the status of an appointment to \"cancelled\" by its ID.
         * @summary Cancel an appointment
         * @param {string} id The ID of the appointment to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsIdCancelPut: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiV1AppointmentsIdCancelPut', 'id', id)
            const localVarPath = `/api/v1/appointments/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change the status of an appointment to \"completed\" by its ID.
         * @summary Complete an appointment
         * @param {string} id The ID of the appointment to complete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsIdCompletePut: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiV1AppointmentsIdCompletePut', 'id', id)
            const localVarPath = `/api/v1/appointments/{id}/complete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an appointment from the system by its ID.
         * @summary Delete an appointment
         * @param {string} id The ID of the appointment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiV1AppointmentsIdDelete', 'id', id)
            const localVarPath = `/api/v1/appointments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of a specific appointment by its ID.
         * @summary Get appointment by ID
         * @param {string} id The ID of the appointment to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiV1AppointmentsIdGet', 'id', id)
            const localVarPath = `/api/v1/appointments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change the status of an appointment to \"no-show\" by its ID.
         * @summary Mark an appointment as no-show
         * @param {string} id The ID of the appointment to mark as no-show
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsIdNoshowPut: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiV1AppointmentsIdNoshowPut', 'id', id)
            const localVarPath = `/api/v1/appointments/{id}/noshow`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify details of an existing appointment by ID.
         * @summary Update an appointment
         * @param {string} id The ID of the appointment to update
         * @param {AppointmentUpdate} appointmentUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsIdPut: async (id: string, appointmentUpdate: AppointmentUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiV1AppointmentsIdPut', 'id', id)
            // verify required parameter 'appointmentUpdate' is not null or undefined
            assertParamExists('apiV1AppointmentsIdPut', 'appointmentUpdate', appointmentUpdate)
            const localVarPath = `/api/v1/appointments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appointmentUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve weather forecast for the location and date of a specific appointment by ID.
         * @summary Get weather forecast for appointment
         * @param {string} id The ID of the appointment for which to retrieve weather information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsIdWeatherGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiV1AppointmentsIdWeatherGet', 'id', id)
            const localVarPath = `/api/v1/appointments/{id}/weather`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all appointments for a specific patient by their ID.
         * @summary Get all appointments for a patient
         * @param {string} patientId The ID of the patient whose appointments to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsPatientPatientIdGet: async (patientId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patientId' is not null or undefined
            assertParamExists('apiV1AppointmentsPatientPatientIdGet', 'patientId', patientId)
            const localVarPath = `/api/v1/appointments/patient/{patientId}`
                .replace(`{${"patientId"}}`, encodeURIComponent(String(patientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schedule a new appointment for a patient with specified details.
         * @summary Create a new appointment
         * @param {AppointmentCreate} appointmentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsPost: async (appointmentCreate: AppointmentCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appointmentCreate' is not null or undefined
            assertParamExists('apiV1AppointmentsPost', 'appointmentCreate', appointmentCreate)
            const localVarPath = `/api/v1/appointments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appointmentCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppointmentsApi - functional programming interface
 * @export
 */
export const AppointmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppointmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve available appointment slots for a specific clinic, doctor, and date.
         * @summary Get available appointment slots
         * @param {string} clinicId The ID of the clinic to check for available appointments
         * @param {string} doctorId The ID of the doctor to check for available appointments
         * @param {string} date The date to check for available appointments (in YYYY-MM-DD format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppointmentsAvailableGet(clinicId: string, doctorId: string, date: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiV1AppointmentsAvailableGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AppointmentsAvailableGet(clinicId, doctorId, date, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentsApi.apiV1AppointmentsAvailableGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all appointments for a specific clinic by its ID.
         * @summary Get all appointments for a clinic
         * @param {string} clinicId The ID of the clinic whose appointments to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppointmentsClinicClinicIdGet(clinicId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Appointment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AppointmentsClinicClinicIdGet(clinicId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentsApi.apiV1AppointmentsClinicClinicIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all appointments for a specific doctor by their ID.
         * @summary Get all appointments for a doctor
         * @param {string} doctorId The ID of the doctor whose appointments to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppointmentsDoctorDoctorIdGet(doctorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Appointment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AppointmentsDoctorDoctorIdGet(doctorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentsApi.apiV1AppointmentsDoctorDoctorIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all appointments in the system.
         * @summary Get all appointments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppointmentsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Appointment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AppointmentsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentsApi.apiV1AppointmentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change the status of an appointment to \"cancelled\" by its ID.
         * @summary Cancel an appointment
         * @param {string} id The ID of the appointment to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppointmentsIdCancelPut(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Appointment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AppointmentsIdCancelPut(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentsApi.apiV1AppointmentsIdCancelPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change the status of an appointment to \"completed\" by its ID.
         * @summary Complete an appointment
         * @param {string} id The ID of the appointment to complete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppointmentsIdCompletePut(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Appointment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AppointmentsIdCompletePut(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentsApi.apiV1AppointmentsIdCompletePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove an appointment from the system by its ID.
         * @summary Delete an appointment
         * @param {string} id The ID of the appointment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppointmentsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1AppointmentsIdDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AppointmentsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentsApi.apiV1AppointmentsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of a specific appointment by its ID.
         * @summary Get appointment by ID
         * @param {string} id The ID of the appointment to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppointmentsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Appointment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AppointmentsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentsApi.apiV1AppointmentsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change the status of an appointment to \"no-show\" by its ID.
         * @summary Mark an appointment as no-show
         * @param {string} id The ID of the appointment to mark as no-show
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppointmentsIdNoshowPut(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Appointment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AppointmentsIdNoshowPut(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentsApi.apiV1AppointmentsIdNoshowPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify details of an existing appointment by ID.
         * @summary Update an appointment
         * @param {string} id The ID of the appointment to update
         * @param {AppointmentUpdate} appointmentUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppointmentsIdPut(id: string, appointmentUpdate: AppointmentUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Appointment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AppointmentsIdPut(id, appointmentUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentsApi.apiV1AppointmentsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve weather forecast for the location and date of a specific appointment by ID.
         * @summary Get weather forecast for appointment
         * @param {string} id The ID of the appointment for which to retrieve weather information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppointmentsIdWeatherGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AppointmentsIdWeatherGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentsApi.apiV1AppointmentsIdWeatherGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all appointments for a specific patient by their ID.
         * @summary Get all appointments for a patient
         * @param {string} patientId The ID of the patient whose appointments to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppointmentsPatientPatientIdGet(patientId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Appointment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AppointmentsPatientPatientIdGet(patientId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentsApi.apiV1AppointmentsPatientPatientIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Schedule a new appointment for a patient with specified details.
         * @summary Create a new appointment
         * @param {AppointmentCreate} appointmentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AppointmentsPost(appointmentCreate: AppointmentCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Appointment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AppointmentsPost(appointmentCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppointmentsApi.apiV1AppointmentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AppointmentsApi - factory interface
 * @export
 */
export const AppointmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppointmentsApiFp(configuration)
    return {
        /**
         * Retrieve available appointment slots for a specific clinic, doctor, and date.
         * @summary Get available appointment slots
         * @param {string} clinicId The ID of the clinic to check for available appointments
         * @param {string} doctorId The ID of the doctor to check for available appointments
         * @param {string} date The date to check for available appointments (in YYYY-MM-DD format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsAvailableGet(clinicId: string, doctorId: string, date: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiV1AppointmentsAvailableGet200ResponseInner>> {
            return localVarFp.apiV1AppointmentsAvailableGet(clinicId, doctorId, date, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all appointments for a specific clinic by its ID.
         * @summary Get all appointments for a clinic
         * @param {string} clinicId The ID of the clinic whose appointments to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsClinicClinicIdGet(clinicId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Appointment>> {
            return localVarFp.apiV1AppointmentsClinicClinicIdGet(clinicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all appointments for a specific doctor by their ID.
         * @summary Get all appointments for a doctor
         * @param {string} doctorId The ID of the doctor whose appointments to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsDoctorDoctorIdGet(doctorId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Appointment>> {
            return localVarFp.apiV1AppointmentsDoctorDoctorIdGet(doctorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all appointments in the system.
         * @summary Get all appointments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Appointment>> {
            return localVarFp.apiV1AppointmentsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Change the status of an appointment to \"cancelled\" by its ID.
         * @summary Cancel an appointment
         * @param {string} id The ID of the appointment to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsIdCancelPut(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Appointment> {
            return localVarFp.apiV1AppointmentsIdCancelPut(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Change the status of an appointment to \"completed\" by its ID.
         * @summary Complete an appointment
         * @param {string} id The ID of the appointment to complete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsIdCompletePut(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Appointment> {
            return localVarFp.apiV1AppointmentsIdCompletePut(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove an appointment from the system by its ID.
         * @summary Delete an appointment
         * @param {string} id The ID of the appointment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1AppointmentsIdDelete200Response> {
            return localVarFp.apiV1AppointmentsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of a specific appointment by its ID.
         * @summary Get appointment by ID
         * @param {string} id The ID of the appointment to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Appointment> {
            return localVarFp.apiV1AppointmentsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Change the status of an appointment to \"no-show\" by its ID.
         * @summary Mark an appointment as no-show
         * @param {string} id The ID of the appointment to mark as no-show
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsIdNoshowPut(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Appointment> {
            return localVarFp.apiV1AppointmentsIdNoshowPut(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify details of an existing appointment by ID.
         * @summary Update an appointment
         * @param {string} id The ID of the appointment to update
         * @param {AppointmentUpdate} appointmentUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsIdPut(id: string, appointmentUpdate: AppointmentUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Appointment> {
            return localVarFp.apiV1AppointmentsIdPut(id, appointmentUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve weather forecast for the location and date of a specific appointment by ID.
         * @summary Get weather forecast for appointment
         * @param {string} id The ID of the appointment for which to retrieve weather information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsIdWeatherGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1AppointmentsIdWeatherGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all appointments for a specific patient by their ID.
         * @summary Get all appointments for a patient
         * @param {string} patientId The ID of the patient whose appointments to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsPatientPatientIdGet(patientId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Appointment>> {
            return localVarFp.apiV1AppointmentsPatientPatientIdGet(patientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedule a new appointment for a patient with specified details.
         * @summary Create a new appointment
         * @param {AppointmentCreate} appointmentCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AppointmentsPost(appointmentCreate: AppointmentCreate, options?: RawAxiosRequestConfig): AxiosPromise<Appointment> {
            return localVarFp.apiV1AppointmentsPost(appointmentCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppointmentsApi - object-oriented interface
 * @export
 * @class AppointmentsApi
 * @extends {BaseAPI}
 */
export class AppointmentsApi extends BaseAPI {
    /**
     * Retrieve available appointment slots for a specific clinic, doctor, and date.
     * @summary Get available appointment slots
     * @param {string} clinicId The ID of the clinic to check for available appointments
     * @param {string} doctorId The ID of the doctor to check for available appointments
     * @param {string} date The date to check for available appointments (in YYYY-MM-DD format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppointmentsApi
     */
    public apiV1AppointmentsAvailableGet(clinicId: string, doctorId: string, date: string, options?: RawAxiosRequestConfig) {
        return AppointmentsApiFp(this.configuration).apiV1AppointmentsAvailableGet(clinicId, doctorId, date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all appointments for a specific clinic by its ID.
     * @summary Get all appointments for a clinic
     * @param {string} clinicId The ID of the clinic whose appointments to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppointmentsApi
     */
    public apiV1AppointmentsClinicClinicIdGet(clinicId: string, options?: RawAxiosRequestConfig) {
        return AppointmentsApiFp(this.configuration).apiV1AppointmentsClinicClinicIdGet(clinicId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all appointments for a specific doctor by their ID.
     * @summary Get all appointments for a doctor
     * @param {string} doctorId The ID of the doctor whose appointments to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppointmentsApi
     */
    public apiV1AppointmentsDoctorDoctorIdGet(doctorId: string, options?: RawAxiosRequestConfig) {
        return AppointmentsApiFp(this.configuration).apiV1AppointmentsDoctorDoctorIdGet(doctorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all appointments in the system.
     * @summary Get all appointments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppointmentsApi
     */
    public apiV1AppointmentsGet(options?: RawAxiosRequestConfig) {
        return AppointmentsApiFp(this.configuration).apiV1AppointmentsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change the status of an appointment to \"cancelled\" by its ID.
     * @summary Cancel an appointment
     * @param {string} id The ID of the appointment to cancel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppointmentsApi
     */
    public apiV1AppointmentsIdCancelPut(id: string, options?: RawAxiosRequestConfig) {
        return AppointmentsApiFp(this.configuration).apiV1AppointmentsIdCancelPut(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change the status of an appointment to \"completed\" by its ID.
     * @summary Complete an appointment
     * @param {string} id The ID of the appointment to complete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppointmentsApi
     */
    public apiV1AppointmentsIdCompletePut(id: string, options?: RawAxiosRequestConfig) {
        return AppointmentsApiFp(this.configuration).apiV1AppointmentsIdCompletePut(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove an appointment from the system by its ID.
     * @summary Delete an appointment
     * @param {string} id The ID of the appointment to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppointmentsApi
     */
    public apiV1AppointmentsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return AppointmentsApiFp(this.configuration).apiV1AppointmentsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details of a specific appointment by its ID.
     * @summary Get appointment by ID
     * @param {string} id The ID of the appointment to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppointmentsApi
     */
    public apiV1AppointmentsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return AppointmentsApiFp(this.configuration).apiV1AppointmentsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change the status of an appointment to \"no-show\" by its ID.
     * @summary Mark an appointment as no-show
     * @param {string} id The ID of the appointment to mark as no-show
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppointmentsApi
     */
    public apiV1AppointmentsIdNoshowPut(id: string, options?: RawAxiosRequestConfig) {
        return AppointmentsApiFp(this.configuration).apiV1AppointmentsIdNoshowPut(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify details of an existing appointment by ID.
     * @summary Update an appointment
     * @param {string} id The ID of the appointment to update
     * @param {AppointmentUpdate} appointmentUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppointmentsApi
     */
    public apiV1AppointmentsIdPut(id: string, appointmentUpdate: AppointmentUpdate, options?: RawAxiosRequestConfig) {
        return AppointmentsApiFp(this.configuration).apiV1AppointmentsIdPut(id, appointmentUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve weather forecast for the location and date of a specific appointment by ID.
     * @summary Get weather forecast for appointment
     * @param {string} id The ID of the appointment for which to retrieve weather information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppointmentsApi
     */
    public apiV1AppointmentsIdWeatherGet(id: string, options?: RawAxiosRequestConfig) {
        return AppointmentsApiFp(this.configuration).apiV1AppointmentsIdWeatherGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all appointments for a specific patient by their ID.
     * @summary Get all appointments for a patient
     * @param {string} patientId The ID of the patient whose appointments to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppointmentsApi
     */
    public apiV1AppointmentsPatientPatientIdGet(patientId: string, options?: RawAxiosRequestConfig) {
        return AppointmentsApiFp(this.configuration).apiV1AppointmentsPatientPatientIdGet(patientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schedule a new appointment for a patient with specified details.
     * @summary Create a new appointment
     * @param {AppointmentCreate} appointmentCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppointmentsApi
     */
    public apiV1AppointmentsPost(appointmentCreate: AppointmentCreate, options?: RawAxiosRequestConfig) {
        return AppointmentsApiFp(this.configuration).apiV1AppointmentsPost(appointmentCreate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticates a user with their email and password.
         * @summary User Login
         * @param {ApiV1LoginPostRequest} apiV1LoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LoginPost: async (apiV1LoginPostRequest: ApiV1LoginPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1LoginPostRequest' is not null or undefined
            assertParamExists('apiV1LoginPost', 'apiV1LoginPostRequest', apiV1LoginPostRequest)
            const localVarPath = `/api/v1/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1LoginPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logs out a user by clearing authentication tokens.
         * @summary User Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LogoutPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks the validity of the token provided in the user\'s cookies.
         * @summary Validates the user\'s token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticates a user with their email and password.
         * @summary User Login
         * @param {ApiV1LoginPostRequest} apiV1LoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1LoginPost(apiV1LoginPostRequest: ApiV1LoginPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1UsersVerify2faPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1LoginPost(apiV1LoginPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.apiV1LoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Logs out a user by clearing authentication tokens.
         * @summary User Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1LogoutPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1LogoutPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1LogoutPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.apiV1LogoutPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Checks the validity of the token provided in the user\'s cookies.
         * @summary Validates the user\'s token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateToken200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.validateToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Authenticates a user with their email and password.
         * @summary User Login
         * @param {ApiV1LoginPostRequest} apiV1LoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LoginPost(apiV1LoginPostRequest: ApiV1LoginPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1UsersVerify2faPost200Response> {
            return localVarFp.apiV1LoginPost(apiV1LoginPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Logs out a user by clearing authentication tokens.
         * @summary User Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1LogoutPost(options?: RawAxiosRequestConfig): AxiosPromise<ApiV1LogoutPost200Response> {
            return localVarFp.apiV1LogoutPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Checks the validity of the token provided in the user\'s cookies.
         * @summary Validates the user\'s token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateToken(options?: RawAxiosRequestConfig): AxiosPromise<ValidateToken200Response> {
            return localVarFp.validateToken(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Authenticates a user with their email and password.
     * @summary User Login
     * @param {ApiV1LoginPostRequest} apiV1LoginPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public apiV1LoginPost(apiV1LoginPostRequest: ApiV1LoginPostRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).apiV1LoginPost(apiV1LoginPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logs out a user by clearing authentication tokens.
     * @summary User Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public apiV1LogoutPost(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).apiV1LogoutPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks the validity of the token provided in the user\'s cookies.
     * @summary Validates the user\'s token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public validateToken(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).validateToken(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Allows authenticated users to change their password.
         * @summary Change user password
         * @param {ApiV1UsersChangePasswordPostRequest} apiV1UsersChangePasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersChangePasswordPost: async (apiV1UsersChangePasswordPostRequest: ApiV1UsersChangePasswordPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1UsersChangePasswordPostRequest' is not null or undefined
            assertParamExists('apiV1UsersChangePasswordPost', 'apiV1UsersChangePasswordPostRequest', apiV1UsersChangePasswordPostRequest)
            const localVarPath = `/api/v1/users/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1UsersChangePasswordPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows authenticated users to enable two-factor authentication.
         * @summary Enable two-factor authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersEnable2faPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/enable-2fa`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete user by user ID. Requires the user to have specific roles.
         * @summary Deletes user
         * @param {string} id ID of the user to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiV1UsersIdDelete', 'id', id)
            const localVarPath = `/api/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve user details by user ID. Requires the user to be the owner or have specific roles.
         * @summary Retrieve user information
         * @param {string} id ID of the user to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiV1UsersIdGet', 'id', id)
            const localVarPath = `/api/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user details by user ID. Requires the user to be the owner or have specific roles.
         * @summary Update user information
         * @param {string} id ID of the user to update
         * @param {ApiV1UsersIdPutRequest} apiV1UsersIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersIdPut: async (id: string, apiV1UsersIdPutRequest: ApiV1UsersIdPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiV1UsersIdPut', 'id', id)
            // verify required parameter 'apiV1UsersIdPutRequest' is not null or undefined
            assertParamExists('apiV1UsersIdPut', 'apiV1UsersIdPutRequest', apiV1UsersIdPutRequest)
            const localVarPath = `/api/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1UsersIdPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new user with specified roles, email, and associated IDs for doctor or patient.
         * @summary Create User
         * @param {ApiV1UsersPostRequest} apiV1UsersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPost: async (apiV1UsersPostRequest: ApiV1UsersPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1UsersPostRequest' is not null or undefined
            assertParamExists('apiV1UsersPost', 'apiV1UsersPostRequest', apiV1UsersPostRequest)
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1UsersPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows authenticated users to verify two-factor authentication.
         * @summary Verify two-factor authentication
         * @param {ApiV1UsersVerify2faPostRequest} apiV1UsersVerify2faPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersVerify2faPost: async (apiV1UsersVerify2faPostRequest: ApiV1UsersVerify2faPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1UsersVerify2faPostRequest' is not null or undefined
            assertParamExists('apiV1UsersVerify2faPost', 'apiV1UsersVerify2faPostRequest', apiV1UsersVerify2faPostRequest)
            const localVarPath = `/api/v1/users/verify-2fa`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1UsersVerify2faPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Allows authenticated users to change their password.
         * @summary Change user password
         * @param {ApiV1UsersChangePasswordPostRequest} apiV1UsersChangePasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersChangePasswordPost(apiV1UsersChangePasswordPostRequest: ApiV1UsersChangePasswordPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1UsersChangePasswordPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersChangePasswordPost(apiV1UsersChangePasswordPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiV1UsersChangePasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows authenticated users to enable two-factor authentication.
         * @summary Enable two-factor authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersEnable2faPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1UsersEnable2faPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersEnable2faPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiV1UsersEnable2faPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete user by user ID. Requires the user to have specific roles.
         * @summary Deletes user
         * @param {string} id ID of the user to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1UsersIdDelete204Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiV1UsersIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve user details by user ID. Requires the user to be the owner or have specific roles.
         * @summary Retrieve user information
         * @param {string} id ID of the user to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1UsersIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiV1UsersIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user details by user ID. Requires the user to be the owner or have specific roles.
         * @summary Update user information
         * @param {string} id ID of the user to update
         * @param {ApiV1UsersIdPutRequest} apiV1UsersIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersIdPut(id: string, apiV1UsersIdPutRequest: ApiV1UsersIdPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1UsersIdPut200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersIdPut(id, apiV1UsersIdPutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiV1UsersIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new user with specified roles, email, and associated IDs for doctor or patient.
         * @summary Create User
         * @param {ApiV1UsersPostRequest} apiV1UsersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersPost(apiV1UsersPostRequest: ApiV1UsersPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1UsersPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersPost(apiV1UsersPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiV1UsersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows authenticated users to verify two-factor authentication.
         * @summary Verify two-factor authentication
         * @param {ApiV1UsersVerify2faPostRequest} apiV1UsersVerify2faPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UsersVerify2faPost(apiV1UsersVerify2faPostRequest: ApiV1UsersVerify2faPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1UsersVerify2faPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UsersVerify2faPost(apiV1UsersVerify2faPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.apiV1UsersVerify2faPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Allows authenticated users to change their password.
         * @summary Change user password
         * @param {ApiV1UsersChangePasswordPostRequest} apiV1UsersChangePasswordPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersChangePasswordPost(apiV1UsersChangePasswordPostRequest: ApiV1UsersChangePasswordPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1UsersChangePasswordPost200Response> {
            return localVarFp.apiV1UsersChangePasswordPost(apiV1UsersChangePasswordPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows authenticated users to enable two-factor authentication.
         * @summary Enable two-factor authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersEnable2faPost(options?: RawAxiosRequestConfig): AxiosPromise<ApiV1UsersEnable2faPost200Response> {
            return localVarFp.apiV1UsersEnable2faPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete user by user ID. Requires the user to have specific roles.
         * @summary Deletes user
         * @param {string} id ID of the user to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1UsersIdDelete204Response> {
            return localVarFp.apiV1UsersIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve user details by user ID. Requires the user to be the owner or have specific roles.
         * @summary Retrieve user information
         * @param {string} id ID of the user to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1UsersIdGet200Response> {
            return localVarFp.apiV1UsersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user details by user ID. Requires the user to be the owner or have specific roles.
         * @summary Update user information
         * @param {string} id ID of the user to update
         * @param {ApiV1UsersIdPutRequest} apiV1UsersIdPutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersIdPut(id: string, apiV1UsersIdPutRequest: ApiV1UsersIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1UsersIdPut200Response> {
            return localVarFp.apiV1UsersIdPut(id, apiV1UsersIdPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user with specified roles, email, and associated IDs for doctor or patient.
         * @summary Create User
         * @param {ApiV1UsersPostRequest} apiV1UsersPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersPost(apiV1UsersPostRequest: ApiV1UsersPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1UsersPost201Response> {
            return localVarFp.apiV1UsersPost(apiV1UsersPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows authenticated users to verify two-factor authentication.
         * @summary Verify two-factor authentication
         * @param {ApiV1UsersVerify2faPostRequest} apiV1UsersVerify2faPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UsersVerify2faPost(apiV1UsersVerify2faPostRequest: ApiV1UsersVerify2faPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1UsersVerify2faPost200Response> {
            return localVarFp.apiV1UsersVerify2faPost(apiV1UsersVerify2faPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Allows authenticated users to change their password.
     * @summary Change user password
     * @param {ApiV1UsersChangePasswordPostRequest} apiV1UsersChangePasswordPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiV1UsersChangePasswordPost(apiV1UsersChangePasswordPostRequest: ApiV1UsersChangePasswordPostRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiV1UsersChangePasswordPost(apiV1UsersChangePasswordPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows authenticated users to enable two-factor authentication.
     * @summary Enable two-factor authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiV1UsersEnable2faPost(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiV1UsersEnable2faPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete user by user ID. Requires the user to have specific roles.
     * @summary Deletes user
     * @param {string} id ID of the user to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiV1UsersIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiV1UsersIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve user details by user ID. Requires the user to be the owner or have specific roles.
     * @summary Retrieve user information
     * @param {string} id ID of the user to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiV1UsersIdGet(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiV1UsersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user details by user ID. Requires the user to be the owner or have specific roles.
     * @summary Update user information
     * @param {string} id ID of the user to update
     * @param {ApiV1UsersIdPutRequest} apiV1UsersIdPutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiV1UsersIdPut(id: string, apiV1UsersIdPutRequest: ApiV1UsersIdPutRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiV1UsersIdPut(id, apiV1UsersIdPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new user with specified roles, email, and associated IDs for doctor or patient.
     * @summary Create User
     * @param {ApiV1UsersPostRequest} apiV1UsersPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiV1UsersPost(apiV1UsersPostRequest: ApiV1UsersPostRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiV1UsersPost(apiV1UsersPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows authenticated users to verify two-factor authentication.
     * @summary Verify two-factor authentication
     * @param {ApiV1UsersVerify2faPostRequest} apiV1UsersVerify2faPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public apiV1UsersVerify2faPost(apiV1UsersVerify2faPostRequest: ApiV1UsersVerify2faPostRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).apiV1UsersVerify2faPost(apiV1UsersVerify2faPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkshiftsApi - axios parameter creator
 * @export
 */
export const WorkshiftsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get workshifts by doctor ID
         * @param {string} doctorId Doctor ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkshiftsDoctorDoctorIdGet: async (doctorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'doctorId' is not null or undefined
            assertParamExists('apiV1WorkshiftsDoctorDoctorIdGet', 'doctorId', doctorId)
            const localVarPath = `/api/v1/workshifts/doctor/{doctorId}`
                .replace(`{${"doctorId"}}`, encodeURIComponent(String(doctorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all workshifts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkshiftsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workshifts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a workshift by ID
         * @param {string} id Workshift ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkshiftsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiV1WorkshiftsIdDelete', 'id', id)
            const localVarPath = `/api/v1/workshifts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a workshift by ID
         * @param {string} id Workshift ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkshiftsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiV1WorkshiftsIdGet', 'id', id)
            const localVarPath = `/api/v1/workshifts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a workshift by ID
         * @param {string} id Workshift ID
         * @param {WorkshiftInput} workshiftInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkshiftsIdPut: async (id: string, workshiftInput: WorkshiftInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiV1WorkshiftsIdPut', 'id', id)
            // verify required parameter 'workshiftInput' is not null or undefined
            assertParamExists('apiV1WorkshiftsIdPut', 'workshiftInput', workshiftInput)
            const localVarPath = `/api/v1/workshifts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workshiftInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new workshift
         * @param {WorkshiftInput} workshiftInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkshiftsPost: async (workshiftInput: WorkshiftInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workshiftInput' is not null or undefined
            assertParamExists('apiV1WorkshiftsPost', 'workshiftInput', workshiftInput)
            const localVarPath = `/api/v1/workshifts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workshiftInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new workshift for a week
         * @param {ApiV1WorkshiftsWeekPostRequest} apiV1WorkshiftsWeekPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkshiftsWeekPost: async (apiV1WorkshiftsWeekPostRequest: ApiV1WorkshiftsWeekPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiV1WorkshiftsWeekPostRequest' is not null or undefined
            assertParamExists('apiV1WorkshiftsWeekPost', 'apiV1WorkshiftsWeekPostRequest', apiV1WorkshiftsWeekPostRequest)
            const localVarPath = `/api/v1/workshifts/week`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1WorkshiftsWeekPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkshiftsApi - functional programming interface
 * @export
 */
export const WorkshiftsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkshiftsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get workshifts by doctor ID
         * @param {string} doctorId Doctor ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkshiftsDoctorDoctorIdGet(doctorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Workshift>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkshiftsDoctorDoctorIdGet(doctorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkshiftsApi.apiV1WorkshiftsDoctorDoctorIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all workshifts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkshiftsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Workshift>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkshiftsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkshiftsApi.apiV1WorkshiftsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a workshift by ID
         * @param {string} id Workshift ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkshiftsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkshiftsIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkshiftsApi.apiV1WorkshiftsIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a workshift by ID
         * @param {string} id Workshift ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkshiftsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workshift>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkshiftsIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkshiftsApi.apiV1WorkshiftsIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a workshift by ID
         * @param {string} id Workshift ID
         * @param {WorkshiftInput} workshiftInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkshiftsIdPut(id: string, workshiftInput: WorkshiftInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workshift>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkshiftsIdPut(id, workshiftInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkshiftsApi.apiV1WorkshiftsIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new workshift
         * @param {WorkshiftInput} workshiftInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkshiftsPost(workshiftInput: WorkshiftInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workshift>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkshiftsPost(workshiftInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkshiftsApi.apiV1WorkshiftsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new workshift for a week
         * @param {ApiV1WorkshiftsWeekPostRequest} apiV1WorkshiftsWeekPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WorkshiftsWeekPost(apiV1WorkshiftsWeekPostRequest: ApiV1WorkshiftsWeekPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Workshift>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WorkshiftsWeekPost(apiV1WorkshiftsWeekPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkshiftsApi.apiV1WorkshiftsWeekPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkshiftsApi - factory interface
 * @export
 */
export const WorkshiftsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkshiftsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get workshifts by doctor ID
         * @param {string} doctorId Doctor ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkshiftsDoctorDoctorIdGet(doctorId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Workshift>> {
            return localVarFp.apiV1WorkshiftsDoctorDoctorIdGet(doctorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all workshifts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkshiftsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Workshift>> {
            return localVarFp.apiV1WorkshiftsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a workshift by ID
         * @param {string} id Workshift ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkshiftsIdDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1WorkshiftsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a workshift by ID
         * @param {string} id Workshift ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkshiftsIdGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Workshift> {
            return localVarFp.apiV1WorkshiftsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a workshift by ID
         * @param {string} id Workshift ID
         * @param {WorkshiftInput} workshiftInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkshiftsIdPut(id: string, workshiftInput: WorkshiftInput, options?: RawAxiosRequestConfig): AxiosPromise<Workshift> {
            return localVarFp.apiV1WorkshiftsIdPut(id, workshiftInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new workshift
         * @param {WorkshiftInput} workshiftInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkshiftsPost(workshiftInput: WorkshiftInput, options?: RawAxiosRequestConfig): AxiosPromise<Workshift> {
            return localVarFp.apiV1WorkshiftsPost(workshiftInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new workshift for a week
         * @param {ApiV1WorkshiftsWeekPostRequest} apiV1WorkshiftsWeekPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WorkshiftsWeekPost(apiV1WorkshiftsWeekPostRequest: ApiV1WorkshiftsWeekPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Workshift>> {
            return localVarFp.apiV1WorkshiftsWeekPost(apiV1WorkshiftsWeekPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkshiftsApi - object-oriented interface
 * @export
 * @class WorkshiftsApi
 * @extends {BaseAPI}
 */
export class WorkshiftsApi extends BaseAPI {
    /**
     * 
     * @summary Get workshifts by doctor ID
     * @param {string} doctorId Doctor ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkshiftsApi
     */
    public apiV1WorkshiftsDoctorDoctorIdGet(doctorId: string, options?: RawAxiosRequestConfig) {
        return WorkshiftsApiFp(this.configuration).apiV1WorkshiftsDoctorDoctorIdGet(doctorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all workshifts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkshiftsApi
     */
    public apiV1WorkshiftsGet(options?: RawAxiosRequestConfig) {
        return WorkshiftsApiFp(this.configuration).apiV1WorkshiftsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a workshift by ID
     * @param {string} id Workshift ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkshiftsApi
     */
    public apiV1WorkshiftsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return WorkshiftsApiFp(this.configuration).apiV1WorkshiftsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a workshift by ID
     * @param {string} id Workshift ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkshiftsApi
     */
    public apiV1WorkshiftsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return WorkshiftsApiFp(this.configuration).apiV1WorkshiftsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a workshift by ID
     * @param {string} id Workshift ID
     * @param {WorkshiftInput} workshiftInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkshiftsApi
     */
    public apiV1WorkshiftsIdPut(id: string, workshiftInput: WorkshiftInput, options?: RawAxiosRequestConfig) {
        return WorkshiftsApiFp(this.configuration).apiV1WorkshiftsIdPut(id, workshiftInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new workshift
     * @param {WorkshiftInput} workshiftInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkshiftsApi
     */
    public apiV1WorkshiftsPost(workshiftInput: WorkshiftInput, options?: RawAxiosRequestConfig) {
        return WorkshiftsApiFp(this.configuration).apiV1WorkshiftsPost(workshiftInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new workshift for a week
     * @param {ApiV1WorkshiftsWeekPostRequest} apiV1WorkshiftsWeekPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkshiftsApi
     */
    public apiV1WorkshiftsWeekPost(apiV1WorkshiftsWeekPostRequest: ApiV1WorkshiftsWeekPostRequest, options?: RawAxiosRequestConfig) {
        return WorkshiftsApiFp(this.configuration).apiV1WorkshiftsWeekPost(apiV1WorkshiftsWeekPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



